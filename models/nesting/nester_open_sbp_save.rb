# Todo
# Need to control where you save the file
# Need to get the project name
# Need to confirm that sheet dimenstions
# What about a thickness slop - for 0.75 material what do we do for not cuttin all tru
# What do we do about tabs
# They need to select the bit
# What do we do about the plunge speed and number of passes
#what about spindle speed
#what about the move speed

#notes
#http://www.talkshopbot.com/forum/showthread.php?12295-Partworks-Tool-Path
#C6 start spindle
#c7 Restart Spindle?
#c9 Change tool
class WikiHouse::NesterOpenSbpSave

  class ProfilePoint
    attr_reader :point, :ref_point, :edge_type, :bit

    def initialize(point: nil, edge_type: :outside, ref_point: nil, bit: nil)
      @point = point
      @ref_point = ref_point
      @edge_type = edge_type
      @bit = bit
      raise ArgumentError, "Must set a point" if @point.nil?
    end

    def outside_edge?
      !inside_edge? && !on_edge?
    end

    def inside_edge?
      @edge_type == :inside_edge
    end

    def on_edge?
      @edge_type == :on_edge
    end

    def global_point
      [gx, gy, gz]
    end

    #raw points
    def x
      @point.x.round(6)
    end

    def y
      @point.y.round(6)
    end

    def z
      @point.z.round(6)
    end

    #Points in terms of the reference point
    def gx
      (x - @ref_point.x).round(6)
    end

    def gy
      (y - @ref_point.y).round(6)
    end

    def gz
      (z - @ref_point.z).round(6)
    end

    #Calculatd based on edge type
    def cx
      if outside_edge?
        (gx).round(6)
      elsif inside_edge?
        (gx).round(6)
      elsif on_edge?
        (gx).round(6)
      end

    end

    def cy
      (gy).round(6)
    end

    def cz
      (gz).round(6)
    end
  end

  def initialize(draw_sheet_outline: false)
    @draw_sheet_outline = draw_sheet_outline
    @sheet = WikiHouse::Config.sheet.new
    @clearance = 0.200
    @bit = WikiHouse::Cnc.bit

  end

  def round(val)
    val.to_f.round(6)
  end

  def sbp_footer
    <<-TXT
#{Osbp.move(z: @clearance + @sheet.thickness)}
    #{Osbp.move(x: 0, y: 0, z: @clearance + @sheet.thickness)}
    #{Osbp.spindle_off}

END

UNIT_ERROR:
#{Osbp.cn_command(number: 91)}
END

    TXT
  end

  def sbp_header
    <<-TXT
'----------------------------------------------------------------
'SHOPBOT ROUTER FILE IN INCHES
'GENERATED BY WikiHouse::OpenSBP

'Length of material in X = #{@sheet.length}
'Length of material in Y = #{@sheet.width}
'Depth of material in Z = #{@sheet.thickness}
'Home Position Information = Bottom Left Corner, Material Surface
'Home X = 0.000000 Home Y = 0.000000 Home Z = #{@sheet.thickness + @clearance}
'Rapid clearance gap or Safe Z = #{@clearance}
'UNITS:Inches
IF %(25)=1 THEN GOTO UNIT_ERROR	'check to see software is set to standard
#{Osbp.use_absolute_coordinates}
    #{Osbp.cn_command(number: 90)}
'New Path
'Toolpath Name = Sheet 1 Pocket 0.375in
'Tool Name   = #{@bit.name}


&Tool =1           'Tool number to change to
#{Osbp.tool_change}
    #{Osbp.set_spindle_speed(speed: 14000)}
    #{Osbp.spindle_on}
    #{Osbp.pause(seconds: 2)}
    #{Osbp.set_cut_speed(xy: WikiHouse::Cnc.xy_speed, z: WikiHouse::Cnc.z_speed)}
    #{Osbp.move(z: @clearance + @sheet.thickness)}
    #{Osbp.new_line}
    TXT
  end

  def save_sheet(project_name: nil, file_name: nil, sheet_group: nil, nesting_group: nil)
    #what if it already exists?
    #puts "#{sheet_group.name} "
    #  sheet_group_transformation = Sk.transformation_chain(sheet_group)

    # nesting_group_points = convert_to_global_position(nesting_group)
    # nesting_group_points.each { |p| puts "#{Sk.point_to_s(p)}"}
    # return
    sheet_group_bounding_box = sheet_group.bounds
    # puts "Height #{sheet_group_bounding_box.height} "
    # puts "Width #{sheet_group_bounding_box.width} "
    # puts "Depth #{sheet_group_bounding_box.depth} "
    if sheet_group_bounding_box.depth != 0
      raise ArgumentError, "You must flatten group before trying to nest it."
    end

    #  puts "Dimensions = #{sheet_group_bounding_box.height * 1.0} x #{sheet_group_bounding_box.width * 1.0}"
    sbp_file = File.new(file_name, "w")
    #What if there is a problem writing to that?
    sbp_file.write sbp_header

    ref_point = find_reference_point(sheet_group)

    sheet_group.entities.each do |e|
      if e.is_a? Sketchup::Group
        # puts "#{e.name}"
        next if e.name == WikiHouse::Nester.sheet_outline_group_name && !@draw_sheet_outline
        face_count = 0
        face = nil
        e.entities.each do |sub_e|
          if sub_e.is_a? Sketchup::Face
            face = sub_e
            face_count += 1
          end
        end
        if face_count != 1
          puts "Sorry this needs to be flat"
        else

          sbp_file.write %Q(#{Osbp.comment("Start #{e.name} #{e.entityID}")}\n)
          sbp_file.write %Q(#{Osbp.dash_line}\n)
          tool_path = WikiHouse::ToolPath.new(clearance: @clearance, sheet: @sheet, bit: @bit)

          face.loops.each do |loop|
            next if !loop.outer? #Focusing on the outer loop for now

            add_loop_to_toolpath(face: face, loop: loop, ref_point: ref_point, tool_path: tool_path)


            sbp_file.write(tool_path.to_s)
          end

          sbp_file.write %Q(#{Osbp.comment("End #{e.name} #{e.entityID}")}\n)
          sbp_file.write %Q(#{Osbp.dash_line}\n)
        end
      end
    end

    sbp_file.write sbp_footer
    sbp_file.close
    puts "Wrote out #{file_name}"
  end


  def add_loop_to_toolpath(face: face, loop: nil, ref_point: nil, tool_path: nil)
    #based on code from Position Explorer
    # Copyright 2010 Glenn Babcock

    tag_dictionary = WikiHouse::AttributeHelper.tag_dictionary
    original_points = loop.vertices.collect { |v| v.position }
    context_points = convert_to_global_position(loop)

    point_map = {}
    original_points.each_with_index do |op, i|
      point_map[Sk.point_to_s(op)] = context_points[i]
    end

    profile_points = []
    last_e = nil
    last_e_type = nil
    loop.edges.each do |e|

      inside_direction = nil
      if e.get_attribute tag_dictionary, "inside_edge"
        profile_type = :inside
      elsif e.get_attribute tag_dictionary, "on_edge"
        profile_type = :on
      else
        profile_type = :outside
      end
      start_point = e.vertices.first.position
      end_point = e.vertices.last.position
      slope = Sk.slope(start_point.x, start_point.y, end_point.x, end_point.y) #Doing it in local co-ordinates
      if slope.nil?

        if face.classify_point([start_point.x, start_point.y, start_point.z]) == Sketchup::Face::PointOnVertex
          calibration_pt = [start_point.x, start_point.y, start_point.z]
          if start_point.y < end_point.y
            calibration_pt[1] = start_point.y + (start_point.y + end_point.y)/2.0
          else
            calibration_pt[1] = start_point.y - (start_point.y + end_point.y)/2.0
          end
          postive_result = face.classify_point([calibration_pt.x + 0.01, calibration_pt.y, calibration_pt.z])
          negative_result = face.classify_point([calibration_pt.x - 0.01, calibration_pt.y, calibration_pt.z])
          if negative_result > 4 && postive_result <= 4
            inside_direction = 1
          elsif negative_result <= 4 && postive_result > 4
            inside_direction = -1
          end


        else
          raise ScriptError, "The start point isn't considered a vertex for the face provided"
        end
      elsif slope == 0
        if face.classify_point([start_point.x, start_point.y, start_point.z]) == Sketchup::Face::PointOnVertex
          calibration_pt = [start_point.x, start_point.y, start_point.z]
          if start_point.x < end_point.x
            calibration_pt[0] = start_point.x + (start_point.x + end_point.x)/2.0
          else
            calibration_pt[0] = start_point.x - (start_point.x + end_point.x)/2.0
          end

          postive_result = face.classify_point([calibration_pt.x, calibration_pt.y + 0.01, calibration_pt.z])
          negative_result = face.classify_point([calibration_pt.x, calibration_pt.y - 0.01, calibration_pt.z])
          if negative_result > 4 && postive_result <= 4
            inside_direction = 1
          elsif negative_result <= 4 && postive_result > 4
            inside_direction = -1
          end


        else
          raise ScriptError, "The start point isn't considered a vertex for the face provided"
        end
      else
        raise ScriptError, "We don't know how to do this slope yet"
      end
      if inside_direction.nil?
        raise ScriptError, "#{slope.nil? ? "Nil" : slope} #{Sk.point_to_s(start_point)} #{Sk.point_to_s(end_point)} Unable to figure out the inside orientation for this edge"
      end
      puts "Adding a line with slope #{slope} and #{inside_direction} for #{profile_type}"
      tool_path.add_line(start_point: point_map[Sk.point_to_s(start_point)],
                         end_point: point_map[Sk.point_to_s(end_point)],
                         profile_type: profile_type,
                         inside_direction: inside_direction)
    end
  end

  def convert_to_global_position(entity)
    #based on code from Position Explorer
    # Copyright 2010 Glenn Babcock
    points = entity.vertices.collect { |v| v.position }
    parent = entity.parent

    while Sk.is_a_component_definition?(parent)
      group_transformation = parent.instances[0].transformation
      points.map! { |p| p.transform! group_transformation }
      parent = parent.instances[0].parent
    end
    points
  end

  def find_reference_point(sheet_group)
    min_x = min_y = min_z = nil
    sheet_group.entities.each do |e|
      if e.is_a? Sketchup::Group
        face_count = 0
        face = nil
        e.entities.each do |sub_e|
          if sub_e.is_a? Sketchup::Face
            face = sub_e
            face_count += 1
          end
        end
        if face_count == 1
          face.loops.each do |loop|
            group_points = convert_to_global_position(loop)
            group_points.each do |p|
              #  puts "looking at #{Sk.point_to_s(p)}"
              min_x = p.x if min_x.nil? || p.x < min_x
              min_y = p.y if min_y.nil? || p.y < min_y
              min_z = p.z if min_z.nil? || p.z < min_z
            end
          end

        end
      end
    end
    [min_x, min_y, min_z]

  end

  def save!
    #ask for the directory /base file name
    base_filename = "OpenSBP"
    base_directory = "C:/Users/delmendo/Desktop"
    project_name = "Square Calibration"
    #Find the nest group
    nesting_group = Sk.find_group_by_name(WikiHouse::Nester.nest_group_name, match_ok: false)
    nesting_group.entities.each do |e|
      save_sheet(project_name: project_name,
                 file_name: "#{base_directory}/#{base_filename}-#{e.name.gsub(" ", "_")}.sbp",
                 sheet_group: e,
                 nesting_group: nesting_group)

    end


  end

end
