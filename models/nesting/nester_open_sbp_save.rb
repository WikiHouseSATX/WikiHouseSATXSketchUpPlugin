# Todo
# Need to control where you save the file
# Need to get the project name
# Need to confirm that sheet dimenstions
# What about a thickness slop - for 0.75 material what do we do for not cuttin all tru
# What do we do about tabs
# They need to select the bit
# What do we do about the plunge speed and number of passes
#what about spindle speed
#what about the move speed

#notes
#http://www.talkshopbot.com/forum/showthread.php?12295-Partworks-Tool-Path
#C6 start spindle
#c7 Restart Spindle?
#c9 Change tool
class WikiHouse::NesterOpenSbpSave
  DECIMAL_PLACES = 6
  class ProfilePoint
    attr_reader :point, :ref_point, :edge_type, :bit

    def initialize(point: nil, edge_type: :outside, ref_point: nil, bit: nil)
      @point = point
      @ref_point = ref_point
      @edge_type = edge_type
      @bit = bit
      raise ArgumentError, "Must set a point" if @point.nil?
    end

    def outside_edge?
      !inside_edge? && !on_edge?
    end

    def inside_edge?
      @edge_type == :inside_edge
    end

    def on_edge?
      @edge_type == :on_edge
    end

    def global_point
      [gx, gy, gz]
    end

    #raw points
    def x
      @point.x.round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    def y
      @point.y.round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    def z
      @point.z.round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    #Points in terms of the reference point
    def gx
      (x - @ref_point.x).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    def gy
      (y - @ref_point.y).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    def gz
      (z - @ref_point.z).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    #Calculatd based on edge type
    def cx
      if outside_edge?
        (gx).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
      elsif inside_edge?
        (gx).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
      elsif on_edge?
        (gx).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
      end

    end

    def cy
      (gy).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end

    def cz
      (gz).round(WikiHouse::NesterOpenSbpSave::DECIMAL_PLACES)
    end
  end

  def initialize(draw_sheet_outline: false)
    @draw_sheet_outline = draw_sheet_outline
    @sheet = WikiHouse::Config.sheet.new
    @clearance = 0.200
    @bit = WikiHouse::Cnc.bit

  end

  def round(val)
    val.to_f.round(DECIMAL_PLACES)
  end

  def sbp_footer
    <<-TXT
#{Osbp.move(z:@clearance + @sheet.thickness)}
#{Osbp.move(x:0, y:0, z:@clearance + @sheet.thickness)}
#{Osbp.spindle_off}

END

UNIT_ERROR:
#{Osbp.cn_command(number: 91)}
END

    TXT
  end

  def sbp_header
    <<-TXT
'----------------------------------------------------------------
'SHOPBOT ROUTER FILE IN INCHES
'GENERATED BY WikiHouse::OpenSBP

'Length of material in X = #{@sheet.length}
'Length of material in Y = #{@sheet.width}
'Depth of material in Z = #{@sheet.thickness}
'Home Position Information = Bottom Left Corner, Material Surface
'Home X = 0.000000 Home Y = 0.000000 Home Z = #{@sheet.thickness + @clearance}
'Rapid clearance gap or Safe Z = #{@clearance}
'UNITS:Inches
IF %(25)=1 THEN GOTO UNIT_ERROR	'check to see software is set to standard
#{Osbp.use_absolute_coordinates}
#{Osbp.cn_command(number: 90)}
'New Path
'Toolpath Name = Sheet 1 Pocket 0.375in
'Tool Name   = #{@bit.name}


&Tool =1           'Tool number to change to
#{Osbp.tool_change}
#{Osbp.set_spindle_speed(speed:14000)}
#{Osbp.spindle_on}
#{Osbp.pause(seconds:2)}
#{Osbp.set_cut_speed(xy:WikiHouse::Cnc.xy_speed, z: WikiHouse::Cnc.z_speed )}
#{Osbp.move(z: @clearance + @sheet.thickness)}
#{Osbp.new_line}
    TXT
  end

  def save_sheet(project_name: nil, file_name: nil, sheet_group: nil, nesting_group: nil)
    #what if it already exists?
    #puts "#{sheet_group.name} "
    #  sheet_group_transformation = Sk.transformation_chain(sheet_group)

    # nesting_group_points = convert_to_global_position(nesting_group)
    # nesting_group_points.each { |p| puts "#{Sk.point_to_s(p)}"}
    # return
    sheet_group_bounding_box = sheet_group.bounds
    # puts "Height #{sheet_group_bounding_box.height} "
    # puts "Width #{sheet_group_bounding_box.width} "
    # puts "Depth #{sheet_group_bounding_box.depth} "
    if sheet_group_bounding_box.depth != 0
      raise ArgumentError, "You must flatten group before trying to nest it."
    end

    #  puts "Dimensions = #{sheet_group_bounding_box.height * 1.0} x #{sheet_group_bounding_box.width * 1.0}"
    sbp_file = File.new(file_name, "w")
    #What if there is a problem writing to that?
    sbp_file.write sbp_header


    max_height = ""
    max_width = ""


    ref_point = find_reference_point(sheet_group)

    sheet_group.entities.each do |e|
      if e.is_a? Sketchup::Group
        # puts "#{e.name}"
        next if e.name == WikiHouse::Nester.sheet_outline_group_name && !@draw_sheet_outline
        face_count = 0
        face = nil
        e.entities.each do |sub_e|
          if sub_e.is_a? Sketchup::Face
            face = sub_e
            face_count += 1
          end
        end
        if face_count != 1
          puts "Sorry this needs to be flat"
        else

          sbp_file.write %Q(#{Osbp.comment("Start #{e.name} #{e.entityID}")}\n)
          sbp_file.write %Q(#{Osbp.dash_line}\n)

          face.loops.each do |loop|

            profile_points = loop_to_profile_points(loop: loop, ref_point: ref_point)


            sbp_file.write %Q(#{Osbp.move(x: profile_points.first.gx,
                                          y:profile_points.first.gy,
                                          z:@clearance)}\n)

            depths = cut_depths(depth: @sheet.thickness)
            depths.each_with_index do |depth, i|
              sbp_file.write %Q(#{Osbp.comment("Pass #{i + 1}")}\n)
              profile_points.each do |pp|
                sbp_file.write %Q(#{Osbp.comment(pp.edge_type)}\n)

                sbp_file.write %Q(#{Osbp.cut(x: pp.cx, y: pp.cy, z: round(depth))}\n)
              end
              #since it is a loop - need to do the first one again
              #   sbp_file.write %Q(M3,#{profile_points.first.gx},#{profile_points.first.gy},#{round(depth)}\n)

            end
          end

          sbp_file.write %Q(#{Osbp.comment("End #{e.name} #{e.entityID}")}\n)
          sbp_file.write %Q(#{Osbp.dash_line}\n)
        end
      end
    end

    sbp_file.write sbp_footer
    sbp_file.close
    puts "Wrote out #{file_name}"
  end


  def cut_depths(depth: nil)

    depths = []
    passes = (depth/@bit.diameter).round
    passes = 1 if passes < 1
    passes.times do |i|
      depths << (depth - (i * @bit.diameter)) * -1
    end
    depths.reverse!
    depths
  end

  def loop_to_profile_points(loop: nil, ref_point: nil)
    #based on code from Position Explorer
    # Copyright 2010 Glenn Babcock
    puts "Outer Loop Found" if loop.outer?
    tag_dictionary = WikiHouse::AttributeHelper.tag_dictionary
    original_points = loop.vertices.collect { |v| v.position }
    context_points = convert_to_global_position(loop)

    point_map = {}
    original_points.each_with_index do |op, i|
      point_map[Sk.point_to_s(op)] = context_points[i]
    end

    profile_points = []
    last_e = nil
    last_e_type = nil
    loop.edges.each do |e|
      if e.get_attribute tag_dictionary, "inside_edge"

        profile_points << ProfilePoint.new(bit: @bit, point: point_map[Sk.point_to_s(e.vertices.first.position)], ref_point: ref_point, edge_type: :inside_edge)
        last_e_type = :inside_edge
      elsif e.get_attribute tag_dictionary, "on_edge"
        profile_points << ProfilePoint.new(bit: @bit, point: point_map[Sk.point_to_s(e.vertices.first.position)], ref_point: ref_point, edge_type: :on_edge)
        last_e_type = :on_edge
      else
        profile_points << ProfilePoint.new(bit: @bit, point: point_map[Sk.point_to_s(e.vertices.first.position)], ref_point: ref_point, edge_type: :outside_edge)
        last_e_type = :outside_edge
      end
      last_e = e
    end
    profile_points << ProfilePoint.new(bit: @bit, point: point_map[Sk.point_to_s(loop.edges.first.vertices.first.position)], ref_point: ref_point, edge_type: last_e_type)


    profile_points
  end

  def convert_to_global_position(entity)
    #based on code from Position Explorer
    # Copyright 2010 Glenn Babcock
    points = entity.vertices.collect { |v| v.position }
    parent = entity.parent

    while Sk.is_a_component_definition?(parent)
      group_transformation = parent.instances[0].transformation
      points.map! { |p| p.transform! group_transformation }
      parent = parent.instances[0].parent
    end
    points
  end

  def find_reference_point(sheet_group)
    min_x = min_y = min_z = nil
    sheet_group.entities.each do |e|
      if e.is_a? Sketchup::Group
        face_count = 0
        face = nil
        e.entities.each do |sub_e|
          if sub_e.is_a? Sketchup::Face
            face = sub_e
            face_count += 1
          end
        end
        if face_count == 1
          face.loops.each do |loop|
            group_points = convert_to_global_position(loop)
            group_points.each do |p|
              #  puts "looking at #{Sk.point_to_s(p)}"
              min_x = p.x if min_x.nil? || p.x < min_x
              min_y = p.y if min_y.nil? || p.y < min_y
              min_z = p.z if min_z.nil? || p.z < min_z
            end
          end

        end
      end
    end
    [min_x, min_y, min_z]

  end

  def save!
    #ask for the directory /base file name
    base_filename = "OpenSBP"
    base_directory = "C:/Users/delmendo/Desktop"
    project_name = "Square Calibration"
    #Find the nest group
    nesting_group = Sk.find_group_by_name(WikiHouse::Nester.nest_group_name, match_ok: false)
    nesting_group.entities.each do |e|
      save_sheet(project_name: project_name,
                 file_name: "#{base_directory}/#{base_filename}-#{e.name.gsub(" ", "_")}.sbp",
                 sheet_group: e,
                 nesting_group: nesting_group)

    end


  end

end
