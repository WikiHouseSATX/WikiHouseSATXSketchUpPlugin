#this code was heavily influnced by SVG Essentials by J. David Eisenberg & Amelia Bellamy-Royds
#TODO
# Optimize the SVG output - Consider switching to an optimized path

class WikiHouse::NesterSvgSave
  def initialize(draw_sheet_outline: false)
    @draw_sheet_outline = draw_sheet_outline
  end

  def self.default_stroke_color
    "black"
  end

  def self.default_stroke_width
    "0.003" #hairline in corel
  end

  def self.svg_header
    <<-TXT
<?xml version="1.0"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

    TXT
  end

  def self.stylesheet
    <<-TXT
  <style type="text/css"><![CDATA[
    .part {
      fill: none;
      stroke: #{default_stroke_color};
      stroke-width: #{default_stroke_width};
    }
  ]]></style>
    TXT
  end

  def save_sheet(project_name: nil, file_name: nil, sheet_group: nil, nesting_group: nil)
    #what if it already exists?
    #puts "#{sheet_group.name} "
    #  sheet_group_transformation = Sk.transformation_chain(sheet_group)

    # nesting_group_points = convert_to_global_position(nesting_group)
    # nesting_group_points.each { |p| puts "#{Sk.point_to_s(p)}"}
    # return
    sheet_group_bounding_box = sheet_group.bounds
    puts "Height #{sheet_group_bounding_box.height} "
    puts "Width #{sheet_group_bounding_box.width} "
    puts "Depth #{sheet_group_bounding_box.depth} "
    if sheet_group_bounding_box.depth != 0
      raise ArgumentError, "You must flatten group before trying to nest it."
    end

    #  puts "Dimensions = #{sheet_group_bounding_box.height * 1.0} x #{sheet_group_bounding_box.width * 1.0}"
    svg_file = File.new(file_name, "w")
    #What if there is a problem writing to that?
    svg_file.write WikiHouse::NesterSvgSave.svg_header


    max_height = ""
    max_width = ""

    svg_file.write %Q(<svg width="#{sheet_group_bounding_box.width * 1.0}in"
height="#{sheet_group_bounding_box.height * 1.0}in"
viewBox="0 0 #{sheet_group_bounding_box.width * 1.0} #{sheet_group_bounding_box.height * 1.0}"
xmlns="http://www.3.org/2000/svg" version="1.1" baseProfile="full">\n)
    svg_file.write WikiHouse::NesterSvgSave.stylesheet
    svg_file.write %Q(<title>#{project_name}</title>\n)
    svg_file.write %Q(<desc>#{sheet_group.name}</desc>\n)
    svg_file.write %Q(<!-- Generated by WikiHouse::NesterSVGSave -->\n)

    #THis line handles converting the co-ordinates from Sketup into SVG
    transform_settings = %Q(transform="translate(0,#{sheet_group_bounding_box.width * 0.5}) scale(1, -1)")
    svg_file.write %Q(<g #{transform_settings}>)
    ref_point = find_reference_point(sheet_group)
    if Sk.is_a_group?(sheet_group)
      sheet_group.entities.each do |e|
        if e.is_a? Sketchup::Group
          puts "#{e.name}"
          next if e.name == WikiHouse::Nester.sheet_outline_group_name && !@draw_sheet_outline
          face_count = 0
          face = nil
          faceless_edges = []
          e.entities.each do |sub_e|
            if sub_e.is_a? Sketchup::Face
              face = sub_e
              face_count += 1
            elsif sub_e.is_a? Sketchup::Edge
              faceless_edges << sub_e
            end
          end
          if face_count != 1
            puts "Sorry this needs to be flat #{face_count}"
          else
            faceless_edges.delete_if do |e|
              face.all_connected.include?(e)
            end
            svg_file.write %Q(<g id="sketchup-entityId-#{e.entityID}">\n)
            svg_file.write %Q(<desc>#{e.name}</desc>\n)
            svg_file.write %Q(<g id="sketchup-entityId-#{e.entityID}-face-#{face.entityID}">\n)
            face.loops.each do |loop|
              #   puts loop.outer? ? "Outer Loop" : "Inner Loop"
              group_points = convert_to_global_position(loop).map { |p| [p.x - ref_point.x, p.y - ref_point.y, p.z - ref_point.z] }
              #    puts "Point is #{group_points.first.x * 1.0} #{group_points.first.y * 1.0}"
              points = group_points.collect { |v| "#{Sk.round(v.x * 1.0)} #{Sk.round(v.y * 1.0)}" }
              svg_file.write %Q(<polygon  class="part" points="#{points.join(", ")}" />\n)
            end
            svg_file.write %Q(</g>\n)
            if faceless_edges.count > 0
              svg_file.write %Q(<g id="faceless-edges-#{e.entityID}">\n)
              svg_file.write %Q(<desc>Edges for #{e.name}</desc>\n)
              puts "Found faceless edges #{faceless_edges.count}"
              faceless_edges.each do |fe|
                write_line(svg_file, ref_point, fe)
              end
              svg_file.write %Q(</g>\n)
            end
            svg_file.write %Q(</g>\n)
          end
        end
      end
    else
      sheet_group.definition.entities.each do |e|
        if e.is_a? Sketchup::Group
          # puts "#{e.name}"
          next if e.name == WikiHouse::Nester.sheet_outline_group_name && !@draw_sheet_outline
          face_count = 0
          face = nil
          e.entities.each do |sub_e|
            if sub_e.is_a? Sketchup::Face
              face = sub_e
              face_count += 1
            end
          end
          if face_count != 1
            puts "Sorry this needs to be flat"
          else
            svg_file.write %Q(<g id="sketchup-entityId-#{e.entityID}">\n)
            svg_file.write %Q(<desc>#{e.name}</desc>\n)
            face.loops.each do |loop|
              #   puts loop.outer? ? "Outer Loop" : "Inner Loop"
              group_points = convert_to_global_position(loop).map { |p| [p.x - ref_point.x, p.y - ref_point.y, p.z - ref_point.z] }
              #    puts "Point is #{group_points.first.x * 1.0} #{group_points.first.y * 1.0}"
              points = group_points.collect { |v| "#{v.x * 1.0} #{v.y * 1.0}" }
              svg_file.write %Q(<polygon  class="part" points="#{points.join(", ")}" />\n)
            end
            svg_file.write %Q(</g>\n)
          end
        end
      end

    end
    svg_file.write %Q(</g>)
    svg_file.write %Q(</svg>)
    svg_file.close
    puts "Wrote out #{file_name}"
  end

  def write_line(svg_file, ref_point,edge)
    svg_file.write %Q(<g id="sketchup-entityId-#{edge.entityID}">\n)
    svg_file.write %Q(<desc>Edge #{edge.entityID}</desc>\n)
    points = convert_to_global_position(edge).map { |p| [p.x - ref_point.x, p.y - ref_point.y, p.z - ref_point.z] }
    svg_file.write %Q(<line  class="part" x1="#{Sk.round(points[0].x)}" y1="#{Sk.round(points[0].y)}" x2="#{Sk.round(points[1].x)}" y2="#{Sk.round(points[1].y)}"/>\n)
    svg_file.write %Q(</g>\n)

  end

  def convert_to_global_position(entity)
    #based on code from Position Explorer
    # Copyright 2010 Glenn Babcock
    points = entity.vertices.collect { |v| v.position }
    parent = entity.parent

    while Sk.is_a_component_definition?(parent)
      group_transformation = parent.instances[0].transformation
      points.map! { |p| p.transform! group_transformation }
      parent = parent.instances[0].parent
    end
    points
  end

  def find_reference_point(sheet_group)
    min_x = min_y = min_z = nil
    if Sk.is_a_group?(sheet_group)
      sheet_group.entities.each do |e|
        if Sk.is_a_group?(e)
          face_count = 0
          face = nil
          e.entities.each do |sub_e|
            if Sk.is_a_face?(sub_e)
              face = sub_e
              face_count += 1
            end
          end
          if face_count == 1
            face.loops.each do |loop|
              group_points = convert_to_global_position(loop)
              group_points.each do |p|
                #  puts "looking at #{Sk.point_to_s(p)}"
                min_x = p.x if min_x.nil? || p.x < min_x
                min_y = p.y if min_y.nil? || p.y < min_y
                min_z = p.z if min_z.nil? || p.z < min_z
              end
            end

          end
        end
      end
    else
      sheet_group.definition.entities.each do |e|
        if Sk.is_a_group?(e)
          face_count = 0
          face = nil
          e.entities.each do |sub_e|
            if Sk.is_a_face?(sub)
              face = sub_e
              face_count += 1
            end
          end
          if face_count == 1
            face.loops.each do |loop|
              group_points = convert_to_global_position(loop)
              group_points.each do |p|
                #  puts "looking at #{Sk.point_to_s(p)}"
                min_x = p.x if min_x.nil? || p.x < min_x
                min_y = p.y if min_y.nil? || p.y < min_y
                min_z = p.z if min_z.nil? || p.z < min_z
              end
            end

          end
        end
      end
    end


    [min_x, min_y, min_z]

  end

  def save!
    #ask for the directory /base file name
    base_filename = "Nested"
    base_directory = "C:/Users/delmendo/Desktop"
    project_name = "Half Height Wall"
    #Find the nest group
    nesting_group = Sk.find_group_by_name(WikiHouse::Nester.nest_group_name, match_ok: false)
    nesting_group.entities.each do |e|
      next if Sk.is_a_construction_line?(e)
      save_sheet(project_name: project_name,
                 file_name: "#{base_directory}/#{base_filename}-#{e.name.gsub(" ", "_")}.svg",
                 sheet_group: e,
                 nesting_group: nesting_group)

    end


  end
end